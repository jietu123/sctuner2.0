好，那我们就把“消融实验”当成一个正式的小课题来设计一遍。
 目标是：以后你写论文的一个小节就叫 **“Ablation Study of the Two Plug-ins”**，直接照这个方案写。

------

## 一、总体思路：4 种配置，2 条数据线，统一指标

### 1.1 四种模型配置（mode）

我们固定 backend（先用 CytoSPACE），改变“插件开关”：

1. **M0：Baseline**
   - 不用任何插件
   - 使用 Stage1 预处理后的默认基因（标准 HVG / 全基因）+ 原始 cell type 注释
2. **M1：SVG 插件 ONLY**
   - 启用 Stage2（SVG+HVG 动态加权）
   - 不启用 Stage3（类型插件）→ 使用原始类型、无 Unknown、无 type_prior
3. **M2：类型插件 ONLY**
   - 启用 Stage3（类型不匹配 / Unknown 插件）
   - 不启用 SVG 权重 → 用 baseline 同一套基因 / HVG
4. **M3：Full Plus（SVG + 类型插件）**
   - Stage2 + Stage3 全启用
   - 就是你平时说的 plus_svg_type

> 这四个配置可以写到 `main.py` 的 `--modes` 参数里，例如：
>  `--modes baseline,svg_only,type_only,svg_type`

### 1.2 两条数据线都做消融

- **模拟线（SimGen + Stage5）**
  - 场景：S0、M1、M2
  - 完整跑 M0–M3 四种模式
  - 用**有真值的主指标**来定性每个插件的作用
- **真实线（real_brca + Stage6）**
  - 同样跑 M0–M3
  - 用**无真值的主指标**看插件在真实数据上的行为是否一致/稳定

------

## 二、模拟数据线上的消融实验设计（Stage5）

### 2.1 实验矩阵

| 场景             | 说明                                       | 运行模式       |
| ---------------- | ------------------------------------------ | -------------- |
| S0_matched       | sc/ST 类型完全匹配                         | M0, M1, M2, M3 |
| M1_sc_missing_Tx | sc 人为缺失某个类型（如 B cell）           | M0, M1, M2, M3 |
| M2_st_missing_Ty | ST 人为稀释/去掉某个类型（如 rare immune） | M0, M1, M2, M3 |

> S0 主看“纯映射质量”；M1、M2 主看类型插件对 mismatch/rare type 的影响。

### 2.2 每个模式到底有什么区别？（在模拟上）

- **M0 Baseline**
  - Gene：baseline （默认 HVG）
  - Type：原始类型，无 Unknown
  - Prior：无额外 type_prior（或只用方法自带默认）
- **M1 SVG only**
  - Gene：用 Stage2 的 `gene_weights` 选出的特征基因
  - Type：仍是原始类型，无 Unknown
  - Prior：无额外 type_prior
     → 主要反映“只改基因选择”的效果。
- **M2 Type only**
  - Gene：用 baseline 那套基因（不改）
  - Type：用 Stage3 的类型合并 + Unknown 映射
  - Prior：使用 Stage3 的 spot×type 先验矩阵
     → 主要反映“只改类型与先验”的效果。
- **M3 Full**
  - Gene：SVG+HVG 动态加权特征
  - Type：类型合并 + Unknown + 先验
     → 两个插件叠加后的最终形态。

### 2.3 模拟线上的主指标怎么用来拆分贡献？

#### 2.3.1 S0（完全匹配场景）

**目的：** 在无 mismatch 的理想环境里，看“基因插件”和“类型插件”对纯映射质量的影响。

主指标（有真值）：

- `JS_mean` / `L1_mean`（spot×type 分布距离）
- 可以加一个 `spot_type_accuracy`（分类视角）

**预期模式：**

- 若 Stage2 确实选到了更好的特征基因：
  - M1 & M3 的 JS/L1 应该优于 M0 & M2；
- 若 Stage3 在无 mismatch 环境下不引入伤害：
  - M2 & M3 的 JS/L1 不应显著劣于对应的 M0 & M1（硬红线）。

**分析方式示例：**

- 一张图：横轴 4 个模式 M0–M3，纵轴 JS_mean，箱线图/条形图；

- 结论范式：

  > “在 S0 场景，启用 SVG 插件（M1, M3）相对 baseline（M0, M2）将 JS_mean 从 0.18 降至 0.16（约 11% 改善），说明在匹配场景下 SVG 选择本身有助于映射质量；类型插件（M2）在该场景下未显著改变 JS_mean，说明其主要作用不在此。”

------

#### 2.3.2 M1（sc 缺类型）

**目的：** 这是**类型插件的主场景**，用来展示 Unknown 处理的价值。

主指标：

- `missing_to_wrongtype_rate`（真值是缺失类型的 mass 被误标为其他具体类型）
- `missing_to_unknown_rate`（被标为 Unknown 的比例）

**四种模式下的预期：**

- **M0（baseline）**：没有 Unknown 机制，missing mass 大量流向错误类型 → wrongtype 高，unknown 低（甚至为 0）。
- **M1（SVG only）**：只改基因，对 missing 类型问题帮助有限 → 指标接近 M0。
- **M2（Type only）**：核心改善：
  - missing_to_wrongtype_rate 明显下降
  - missing_to_unknown_rate 明显上升
- **M3（Full）**：在 M2 的基础上，如果 SVG 基因对类型区分更清晰，可能进一步减少 wrongtype 或更好的空间定位。

**分析方式：**

- 一张图：
  - 左侧条形图：`missing_to_wrongtype_rate`（4 模式）
  - 右侧条形图：`missing_to_unknown_rate`（4 模式）

**结论示例：**

> “在 M1 场景（sc 缺 B cell）中，单独启用类型插件（M2）将 missing_to_wrongtype_rate 从 0.72 降至 0.35（改善 51%），同时 missing_to_unknown_rate 从 0.03 提高至 0.49，显示类型插件显著改善了对缺失类型的处理；SVG 插件单独启用（M1）与 baseline（M0）差异不大，说明此场景下主要贡献来自类型插件。”

------

#### 2.3.3 M2（ST 缺类型 / rare type 场景）

**目的：** 看类型插件是否能抑制“稀有类型虚假扩散”。

主指标：

- `false_positive_spots(T_rare)`
- `T_rare_pred_entropy` vs `T_rare_truth_entropy`

**四种模式预期：**

- M0：rare type 可能被 solver 到处“抹一层”；
- M1：仅改基因，仍难解决 rare type 虚假扩散；
- M2：引入先验和 Unknown 后，应减少虚假扩散；
- M3：在 M2 基础上，如果 SVG 对 rare type 区域更敏感，可能进一步收紧其空间范围。

**分析方式：**

- 条形图：`false_positive_spots` 的 4 模式对比。
- 补充图：T_rare 在空间上的热图（baseline vs type_only vs full）。

**解释范式：**

> “在 M2 场景中，类型插件（M2, M3）将 rare type 的虚假阳性 spot 数从 96 减少到 40（降低 58%），而单独启用 SVG 插件（M1）几乎无改善，说明稀有类型的控制主要依赖类型插件的先验约束；在 full 模式（M3）下，虚假阳性进一步微降到 35，同时空间分布更集中于真实富集 block。”

------

### 2.4 模拟线上的 ablation 小结表（Stage7 用）

可以设计一个汇总表（每行一个场景，列是 4 模式的主指标），
 论文里可以放在 Supplement / Main Table 中。

------

## 三、真实数据线上的消融实验设计（Stage6）

在真实 BRCA 上，我们没有真值，但依然可以用同样的 4 种模式 M0–M3 看趋势。

### 3.1 对模块一的消融（SVG 插件）

主指标（真实线）：

- `svg_gene_reconstruction_corr`（SVG 基因的 per-gene corr 分布）
- `marker_gene_reconstruction_corr`（各类 marker 基因的 per-gene corr 分布）

**对比重点：**

- M0 vs M1：纯看“只开 SVG 插件”对重构相关性的影响；
- M2 vs M3：在有类型插件时，加不加 SVG 对表现有无增益；
- 若 M1 & M3 一致优于对应的 M0 & M2，能说明 SVG 插件在真实数据上也有贡献。

### 3.2 对模块二的消融（类型插件）

主指标（真实线）：

- `corr_type_marker(t)`（类型 vs marker 一致性）
- Unknown vs 误差一致性 `corr(U, E)`，`corr(U, D)`

**比较方式：**

- 比较 M0/M1（无类型插件） vs M2/M3（有类型插件）：
  - 对关键类型 t，看 `corr_type_marker` 是否提升；
  - 对 Unknown 看是否在“误差大/不一致高”的区域更集中。

**例子：**

- 若 Tumor 类型的 `corr_type_marker`：
  - baseline (M0, M1)：0.62
  - type_only (M2)：0.67
  - full (M3)：0.69
     → 可以说“类型插件显著提高 Tumor 类型的空间一致性，full 配置进一步小幅改善”。

### 3.3 综合防守：cost / 约束 / 空间结构

为了证明消融不会让方法“变坏”，还可以比较：

- 每个模式的 CytoSPACE `mean_cost_per_cell`；
- `spot_total_count_rmse`；
- 邻域一致性（neighborhood_consistency）——看类型空间是否变得过于碎片化。

要求：

- M1 / M2 / M3 中没有谁在这些“安全指标”上相对 M0 出现极端恶化（>10–20% 坏化）。

------

## 四、在代码里如何支持 4 模式消融？

### 4.1 main.py 多一个 `--modes` 参数

```python
parser.add_argument(
    "--modes",
    type=str,
    default="baseline,svg_only,type_only,svg_type",
    help="模型配置模式列表"
)
```

在 `run_pipeline_for_sample` 里：

```python
modes = [m.strip() for m in args.modes.split(",") if m.strip()]

if "4" in stages:
    for backend in backends:
        for mode in modes:
            stage4_mapping.run_stage4_mapping(
                cfg, sample_id, backend=backend, mode=mode, is_sim=is_sim
            )
```

### 4.2 Stage4 根据 mode 控制是否加载 Stage2 / Stage3 输出

```python
def run_stage4_mapping(cfg, sample_id, backend, mode, is_sim):

    use_svg = mode in ("svg_only", "svg_type")
    use_type_plugin = mode in ("type_only", "svg_type")

    sc_proc = cfg.stage1_sc_processed_path(sample_id, is_sim)
    st_proc = cfg.stage1_st_processed_path(sample_id, is_sim)

    svg_info = cfg.stage2_svg_output(sample_id, is_sim) if use_svg else None
    type_info = cfg.stage3_type_output(sample_id, is_sim) if use_type_plugin else None

    out_dir = cfg.stage4_mapping_outdir(sample_id, backend, mode, is_sim)

    # 传给 cytospace_backend.run_cytospace(...)
```

### 4.3 Stage5 / Stage6 在计算指标时区分 mode

所有 metrics JSON 增加一层 `mode` 维度，例如：

```json
{
  "backend": "cytospace",
  "scenario": "M1_sc_missing_Bcell",
  "metrics": {
    "baseline": { ... },
    "svg_only": { ... },
    "type_only": { ... },
    "svg_type": { ... }
  }
}
```

这样 Stage7 做图的时候就可以：

- 横轴：mode（M0–M3）
- 纵轴：主指标
- 多个场景并排画，从而一眼看到每个插件在不同场景里的贡献模式。

------

## 五、论文里可以怎样讲这套消融？

最后帮你想好几句话，将来可以直接写在论文里：

1. **设计描述：**

> “To attribute the contribution of each plug-in, we performed ablation experiments with four configurations: (i) Baseline (no plug-in), (ii) SVG-only, (iii) Type-only, and (iv) Full (SVG + Type). All configurations share the same preprocessing and mapping backend (CytoSPACE), differing only in feature selection and type prior components.”

1. **模拟线结果总结：**

> “On matched simulations (S0), the SVG-only and Full configurations consistently reduced the JS divergence between predicted and true spot-wise type distributions, indicating that the SVG plug-in improves mapping quality even without type mismatch. On mismatch simulations (M1/M2), the Type-only and Full configurations significantly decreased the fraction of missing types erroneously assigned to wrong types and reduced false positive spread of rare types, demonstrating that the type plug-in is the main driver for handling type mismatch scenarios.”

1. **真实线结果总结：**

> “On real BRCA data, the SVG-only and Full configurations showed improved reconstruction correlation for spatially variable genes, while the Type-only and Full configurations enhanced marker–type concordance and assigned higher Unknown probability to spots with poor reconstruction or marker inconsistency, without substantially increasing the CytoSPACE objective or violating cell count constraints.”

------

